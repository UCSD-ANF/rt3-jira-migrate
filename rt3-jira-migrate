#!/opt/csw/bin/perl
#
use warnings;
use strict;

package rt3jiramigrate;

# Modify this to point to the Request Tracker installation location
use lib "/opt/rt3/lib";

# Need this to make sure we're writing clean XML
use XML::Writer;
use IO::File;

# Import RT's API
use RT::Interface::CLI qw(CleanEnv loc);
use RT::Tickets;
use Data::Dumper;

use POSIX;

#
# Configuration
#

my $outfilename="rt3-jira-migrate.out.jelly"; # Output file location for JIRA Jelly

#
# Instance variables
#

my @components = []; # List of components to create
my @milestones = []; # List of milestones to create
my @users = []; # List of users to create

my $writer; # XML-Writer instance for Jelly file
my $output; # Output IO handle for XML-Writer

# Map of RT users to Jira users
my %usermap = (
  rob           => "rnewman",
);

# Function to map RT users to Jira users
sub mapUser($){
  my $user=shift;
  my $default = shift;

  return $default if ($user eq "");

  push (@users,$user) unless grep (/^$user$/,@users);

  $user = $usermap{$user} if exists $usermap{$user};

  return $user;
}

# Remove invalid XML unicode characters
# This function ensures that the output string has only valid XML Unicode 
# characters as specified by the XML 1.0 standard. For reference, please 
# see the standard: 
#   http://www.w3.org/TR/REC-xml/#charsets
#
# This function will return an empty string if the input is null or empty.
#
# Solution cobbled together based on this post:
# http://cse-mjmcl.cse.bris.ac.uk/blog/2007/02/14/1171465494443.html
sub cleanXML($) {
  my $input=shift;
  my $output=$input; # string to hold the output
  unless ($input) {
    print STDERR "cleanXML: no input\n";
    return '';
  }

  $output =~ s/[^\x{0009}\x{000A}\x{000D}\x{0020}-\x{D7FF}\x{E000}-\x{FFFD}\x{10000}-\x{10FFFF}]//g;
  printf STDERR "cleanXML: removed %d chars from input\n", length($input)-length($output);
  return $output;
}

# Map of RT priority numbers to Jira priorities
my %prioritymap = (
  3     =>      "Major",
  2     =>      "Critical",
  4     =>      "Minor",
  1     =>      "Blocker",
  5     =>      "Trivial",
  99    =>      "Blocker",
  0     =>      "Trivial",
  15    =>      "Major",
  10    =>      "Major",
);

# Function to map RT priorities to Jira Priorities
sub mapPriority($){
  my $priority=shift;
  my $default = "Minor";
  return $default if ($priority eq "");

  if ( exists($prioritymap{$priority}) ){
    $priority = $prioritymap{$priority};
  } else {
    print STDERR "Fallback to Jira priority $default for RT priority $priority\n";
    $priority = $default;
  }
  return $priority;
}

my %queuemap = (
  General       => "SYS",
  LACOFD        => "LACOFD",
  ROADNet       => "ROADNET",
  ANZA          => "ANZA",
  SysAdmin      => "SYS",
  webapps       => "WWW",
  Backups       => "BACKUP",
  WebDev        => "WWW",
  USArray       => "TA",
  HiSeasNet     => "HSN",
  PBO           => "PBO",
);

# Map RT Quenename to Jira project Key
sub mapQueueToProject($){
  my $queue=shift;
  my $default="SYS";

  return $default if ($queue eq "");

  if (exists $queuemap{$queue}) {
    $queue=$queuemap{$queue};
  } else {
    print STDERR "Fallback to $default project for RT queue $queue\n";
    $queue=$default;
  }
  return $queue;
}

# Initilize RT
sub initRT {
  CleanEnv(); # Clean out all the nasties from the environment
  RT::LoadConfig(); # Load RT's config file
  RT::Init(); # Connect to the database. Set up logging

  return
}

sub startJellyOutput () {
# Start outputting XML
  $output = new IO::File(">$outfilename");
  $writer = new XML::Writer(OUTPUT => $output, 
    ENCODING => 'utf-8',
    #   NEWLINES => 'true',
    DATA_MODE => 'true',
    DATA_INDENT => '2'
  );

  $writer->xmlDecl();

# Start Writing Jelly
  $writer->startTag('JiraJelly', 'xmlns:jira' => 'jelly:com.atlassian.jira.jelly.enterprise.JiraTagLib');

  return;
}

sub finishJellyOutput () {
# Done with Jelly
  $writer->endTag('JiraJelly');

# Finish outputting XML
  $writer->end();
  $output->close();
}

sub getRTTicketDescription($){
  my $Ticket = shift;

  my $Transactions = $Ticket->Transactions;

  return unless $Transactions->Count > 0;

  my $Transaction = $Transactions->First;

  return $Transaction->Content;
}

sub jellyCreateTicket($) {
  my $ticket = shift;
  my $ownerUser = new RT::User($RT::SystemUser);
  $ownerUser->Load($ticket->Owner);

  my $requestors = $ticket->Requestors->UserMembersObj;
  my $firstrequestor = "";
  $firstrequestor = $requestors->Next->Name unless ($requestors->Count < 1);

  # Create Issue
  $writer->startTag('jira:CreateIssue', 
    'project-key' => mapQueueToProject($ticket->QueueObj->Name),
    issueKeyVar => 'key',
    summary => $ticket->Subject,
    priority => mapPriority($ticket->Priority),
    reporter => mapUser($firstrequestor),
    assignee => mapUser($ownerUser->Name),
    description => cleanXML(getRTTicketDescription($ticket)),
  );

  # Insert RT3 Ticket Number Custom Field
  $writer->emptyTag('jira:AddCustomFieldValue',
    id=>'RT3 Ticket Number', value=>$ticket->Id);

  my $CustomFields = $ticket->CustomFields;
  while ( my $CustomField = $CustomFields->Next ) {
    my $Values = $ticket->CustomFieldValues( $CustomField->Id );
    my $count = $Values->Count;
    printf STDERR "Processing CustomField %s (%d values)\n", $CustomField->Name, $count;
    while ( my $Value = $Values->Next ) {
      $writer->emptyTag('jira:AddCustomFieldValue',
        id=>$CustomField->Name, value=> $Value->Content);
    }
  }

  # End Issue
  $writer->endTag('jira:CreateIssue');
}

# foreach comment: generate jelly script to add a comment to existing ticket
sub processTicketTransactions($) {
  my $Ticket=shift;     # input RT::Ticket object
  my $Transactions = $Ticket->Transactions; # Transactions from the current ticket
  my $type;             # transaction type

  while (my $Transaction = $Transactions->Next) {

    $type=$Transaction->Type;
    printf STDERR "Transaction %d has type \"%s\"\n", $Transaction->Id, $type;

    if ( $type =~ /^(Create|Comment|Correspond)$/i ) {
      # Process transaction as a comment

      next unless $Transaction->ContentObj; # Bail out if this has no content

      my $transuser = &rt3jiramigrate::mapUser($Transaction->CreatorObj->Name);
      my $transcontent = $Transaction->Content;
      my $transdate = fmtDateSQL2Jelly($Transaction->Created);

      # for some reason there are some Comments in our queue that have no actual 
      # text content, but there is a ContentObj associated with them.
      # Skip those transactions with the null string as content
      next unless $transcontent;

      jellyAddComment($transuser,$transdate,$transcontent); # Add the Jelly Command
    }
  }
}

# Format a Date in SQL format in a Jira Jelly-ready format
sub fmtDateSQL2Jelly ($) {
  my $sqldate=shift;    # input date in SQL date format
  my $date_obj;         # RT::Date parser
  my $result;           # output in Jelly format

  $date_obj = RT::Date->new( RT->SystemUser ); 
  $date_obj->Set(
    Format => 'sql',
    Value  => $sqldate,
  );
  $result = strftime("%Y-%m-%d %H:%M:%S.0", 
    @{ [ localtime( $date_obj->Unix ) ] } );

  return $result;
}

# Output Jira Jelly to add a comment. Assumes that the issueKeyVar of the previous ticket was set to "key"
sub jellyAddComment($$$){
  my $commenter = shift;
  my $date = shift;
  my $comment = shift;

  $writer->emptyTag('jira:AddComment',
    'issue-key'=>'${key}',
    commenter=>$commenter,
    date=>$date,
    comment=>&rt3jiramigrate::cleanXML($comment));
}

sub processTicket($) {
  my $ticket = shift;
  print STDERR "Processing RT Ticket #" . $ticket->Id . "\n";

  &jellyCreateTicket($ticket);

  &rt3jiramigrate::processTicketTransactions($ticket);
}

######### MAIN #########

# Initilize our connection to RT
initRT();

# print banner
print STDERR loc('Hello!') . "\n";

# Get a list of all tickets in RT
# Since RT::Tickets inherits from DBIx::SearchBuilder, no results show up
# unless search conditions are specified.
my $tickets= new RT::Tickets($RT::SystemUser);
$tickets->LimitId( OPERATOR => '>', VALUE => '0');
# Comment previous line and uncomment the following two lines for test tix
#$tickets->LimitId(OPERATOR => '>', VALUE => '1322');
#$tickets->LimitId(OPERATOR => '<', VALUE => '1325');

# Print how many tickets we have
my $count = $tickets->Count;
print STDERR "\$tickets->Count is ".$tickets->Count."\n";

# get ready to write Jelly
startJellyOutput();

# Issues
$writer->comment('ISSUES');
while (my $ticket = $tickets->Next) {
  processTicket($ticket);
}

# finish up our XML document
finishJellyOutput();
