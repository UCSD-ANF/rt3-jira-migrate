#!/opt/csw/bin/perl
#
use warnings;
use strict;

package rt3jiramigrate;

# Modify this to point to the Request Tracker installation location
use lib "/opt/rt3/lib";

use JellyWriter;

# Need this to make sure we're writing clean XML
use XML::Writer;
use IO::File;

# Import RT's API
use RT::Interface::CLI qw(CleanEnv loc);
use RT::Tickets;
use Data::Dumper;

use POSIX;

#
# Configuration
#

# output file format variables
#
# Because the Jelly parser is a huge memory hog, it can't handle all 1700+
# tickets at once. The following variables control the automatic splitting of
# output files.
my $outdir="/home/davis/src/IGPP/rt3-jira-migrate/data";
my $outfnprefix="rt3-jira-migrate-"; # output file prefix
my $outfnsuffix=".jelly"; # output file suffix
my $numtixperfile=1; # Maximum number of tickets per file

# The username to use as the reporter when an RT transaction is from a non-JIRA user
my $anonuser = "anon";

# The Jira custom field used to track the RT ticket number
my $rttktidfn="RT3 Ticket Number";

my $jellywriter; # JellyWriter object

my %anonusers; # List of RT users that are treated as the anonymous user, key is username, value is count

# Map of RT users to Jira users
my %usermap = (
  'rob'           => 'rnewman',
  'rmellors@geology.sdsu.edu' => 'rmellors',
  'lastiz@ucsd.edu' => 'lastiz',
  'RT_System' => 'davis',
  'Nobody' => 'davis',
  'eakins@epicenter.ucsd.edu' => 'eakins',
  'davis@epicenter.ucsd.edu' => 'davis',
  'jeakins@unavco.org' => 'eakins',
  'danny@brtt.com' => 'danny',
  'leyer@ucsd.edu' => 'leyer',
  'pavlis@indiana.edu' => 'pavlis',
  'allan.sauter@gmail.com' => 'sauter',
  'geoff@geoffdavis.com' => 'davis',
  'busby@iris.edu' => 'busby',
  'rnitz@comm-systems.com' => 'rnitz',
  'jkim@sciences.sdsu.edu' => 'jkim',
  'vernon@brtt.com' => 'vernon',
  'davidechavez@gmail.com' => 'dechavez',
  'dchavez@ucsd.edu' => 'dechavez',
  'jbytof@ucsd.edu' => 'jbytof',
  'thim22@gmail.com' => 'thim',
  'dcconstant@ucsd.edu' => 'delia',
  'root' => 'davis',
  'reyes@ucsd.edu' => 'reyes',
  'hafner@iris.edu' => 'hafner',
  'k9pv@sdc.org' => 'k9pv',
  'eakins.jennifer@gmail.com' => 'eakins',
  'judy@ucsd.edu' => 'judy',
  'jdigjudy@gmail.com' => 'judy',
  'tshansen@nlanr.net' => 'tshansen',
  'tshansen@ucsd.edu' => 'tshansen',
  'tshansen@hpwren.ucsd.edu' => 'tshansen',
  'kent' => 'lindquist',
  'clemesha@gmail.com' => 'aclemesh',
  'taimi' => 'tmulder',
);

# Function to map RT users to Jira users
#
# Since we are not creating new Jira users automatically, any unknown email
# address needs to be mapped to an anonymous user. This mimics the behavior of
# the Jira "Mail Service Handler" with createusers="false" and 
# reporterusername="anon"
# This function expects to get passed an RT::User object
sub mapUser($) {
  my $rtuser=shift; # an RT::User object
  my $name; #bare RT username
  my $jirauser; #username to return

  $name=$rtuser->Name; # Cache the username from the RT::User object
  if ($rtuser->Privileged){
    # If the user is a privileged RT user, we assume the user exists in Jira,
    # rather than returning an anonymous user
    $jirauser=$name;
    # We then check to see if the RT username has been mapped to a different
    # Jira username
    if (exists $usermap{$name}){
      $jirauser=$usermap{$name};
    }
  }
  else {

    # The user is not a privileged RT user
    # but it may be mapped to a real jira user
    # Remap the username if the username is in the map 
    if (exists $usermap{$name}){
      $jirauser=$usermap{$name};
    }
    else {
      # We have an anonymous user. Log it.
      $jirauser=$anonuser;
      $anonusers{$name}++;
    }

  }
  return $jirauser;
}

# isAnon takes a ref to a RT::User object and determines if the user is an anonymous user.
# The following logic applies:
# if RT::User says it's a privileged user in RT, isAnon returns false
# elsif mapUser has an entry for the RTUser that is not $anonuser, isAnon returns false
# else isAnon returns true
sub isAnon($){
  my $rtUser=shift;
  my $name = $rtUser->Name;

  if ($rtUser->Privileged) {
    return 0;
  }
  elsif ( grep (/^$name$/,keys(%usermap))) {
    # user was found in the usermap, so we'll assume it's in Jira
    return 0;
  } 

  # User is anonymous
  # don't log, we'll let mapUser do the logging in anonusers
  return 1;
}

# Map of RT priority numbers to Jira priorities
my %prioritymap = (
  3     =>      "Major",
  2     =>      "Critical",
  4     =>      "Minor",
  1     =>      "Blocker",
  5     =>      "Trivial",
  99    =>      "Blocker",
  0     =>      "Trivial",
  15    =>      "Major",
  10    =>      "Major",
);

# Function to map RT priorities to Jira Priorities
sub mapPriority($){
  my $priority=shift;
  my $default = "Minor";
  return $default if ($priority eq "");

  if ( exists($prioritymap{$priority}) ){
    $priority = $prioritymap{$priority};
  } else {
    print STDERR "Fallback to Jira priority $default for RT priority $priority\n";
    $priority = $default;
  }
  return $priority;
}

my %queuemap = (
  General       => "SYS",
  LACOFD        => "LACOFD",
  ROADNet       => "ROADNET",
  ANZA          => "ANZA",
  SysAdmin      => "SYS",
  webapps       => "WWW",
  Backups       => "BACKUP",
  WebDev        => "WWW",
  USArray       => "TA",
  HiSeasNet     => "HSN",
  PBO           => "PBO",
);

# Map RT Quenename to Jira project Key
sub mapQueueToProject($){
  my $queue=shift;
  my $default="SYS";

  return $default if ($queue eq "");

  if (exists $queuemap{$queue}) {
    $queue=$queuemap{$queue};
  } else {
    print STDERR "Fallback to $default project for RT queue $queue\n";
    $queue=$default;
  }
  return $queue;
}

# Map of RT Custom Field names to their Jira names, and a processing function to handle multple values for a field.
# defaults are specifed in the "-default-" record
#
# If no jiraname is specified, it defaults to the RT Field Name
my %cfmap = (
  "Documentation Link" => { 
    jiraname => "Documentation Link", 
    procfunc => \&multiurl2textfield,
  },
  "Vendor Ticket #" => {
    jiraname => "Vendor Ticket Id",
  },
  "Sat Station" => {
    jiraname => "Satellite Station",
    procfunc => \&multitext2multiselect,
  },
  Server => {
    jiraname => "Hosts Affected",
  },
  "-default-" => {
    procfunc => \&multitext2textfield,
  }
);

# Combine multiple values in an RT Multiple Value text field into a single text field, and generate jelly tag only if there are values
# Params:
#  The Jira Field Name
#  A reference to an array containing the RT field values
sub multitext2textfield($$){
  my $jirafieldname = shift;
  my $values_ref = shift;

  $jellywriter->jellyAddCustomFieldValue($jirafieldname, join ("\n", @$values_ref)) if scalar @$values_ref;
}

# combine multiple URL entries from an RT CustomField into a single Jira CustomField
sub multiurl2textfield($$){
  my $fieldname = shift; # The Jira Name of the Custom Field
  my $values_ref = shift; # A reference to an array containing values
  my @cleanvals; # array to hold the URLS stripped of their surrounding wikitext markup
  my $finalval; # the value that actually gets put into the Jira Custom Field

  # Don't do anything unless we have values to process
  return unless (scalar @$values_ref > 0) ;

  # Strip off wikitext square braces around URLs
  # There may be multiple lines in the wikitext area so split that up
  foreach my $val (@$values_ref) {
    my @linevals=split (/\n/, $val);
    foreach my $lineval (@linevals) {
      $lineval =~ s/^\[(.*)\]$/$1/;
      push @cleanvals, $lineval;
    }
  }

  $finalval = join ("\n", @cleanvals);
  $jellywriter->jellyAddCustomFieldValue($fieldname, $finalval);
}

sub multitext2multiselect($$){
  my $jirafieldname = shift;
  my $values_ref = shift;

  foreach my $val (@$values_ref) {
    $jellywriter->jellyAddCustomFieldValue($jirafieldname, $val);
  }
}

# Map RT Custom Field Names to Jira Custom Field Names
sub mapCFNames ($) {
  my $field=shift;

  $field=$cfmap{$field}{'jiraname'} if (exists $cfmap{$field}{'jiraname'});

  return $field;
}

# Map RT Custom Fields to a processing function
# returns a reference to a function
sub mapCFProc ($) {
  my $field=shift;

  if (exists $cfmap{$field}{'procfunc'}) {
    return $cfmap{$field}{'procfunc'};
  }
  return $cfmap{'-default-'}{'procfunc'};
}

sub processTicketCustomFields($){
  my $Ticket=shift;

  my $CustomFields = $Ticket->CustomFields;
  while ( my $CustomField = $CustomFields->Next ) {
    my $rtfn=$CustomField->Name;
    my $jirafn=mapCFNames($rtfn);

    my $CFVals=$Ticket->CustomFieldValues( $CustomField->Id);

    # skip field if there aren't any values to process
    next unless ($CFVals->Count > 0);

    my $cfval_ref=$CFVals->ItemsArrayRef;

    # Extract the content of the custom field values and put it into an array
    my @vals = map { $_->Content } @$cfval_ref;
    &mapCFProc($rtfn)->($jirafn,\@vals);
  }
}

# Initilize RT
sub initRT {
  CleanEnv(); # Clean out all the nasties from the environment
  RT::LoadConfig(); # Load RT's config file
  RT::Init(); # Connect to the database. Set up logging

  return
}

sub getRTTicketDescription($){
  my $Ticket = shift;

  my $Transactions = $Ticket->Transactions;

  return unless $Transactions->Count > 0;

  my $Transaction = $Transactions->First;
  $Transactions->GotoItem(0); # reset transactions index

  return $Transaction->Content;
}

sub processTicketObj($) {
  my $ticket = shift;

  # Skip deleted tickets
  if ($ticket->Status eq 'deleted'){
    printf STDERR "NOTICE: skipping deleted ticket %s\n", $ticket->Id;
    return;
  }

  my $ownerUser = new RT::User($RT::SystemUser);
  $ownerUser->Load($ticket->Owner);
  my $jiraowner; # the Jira owner of the ticket
  if ($ownerUser->Name eq "Nobody") {
    # let jira auto-assign the owner based on queue policy
    $jiraowner="-1";
  }
  else {
    # use the mapUser function to find the jira user
    $jiraowner=mapUser($ownerUser);
  }

  # Get the ticket description
  my $ticketdesc=getRTTicketDescription($ticket);
  my $requestors = $ticket->Requestors->UserMembersObj; # Returns a group object

  # Determine a requestor to use
  # Due to merging or other operations, multiple requestors can be assigned to a ticket.
  # We'll only use one, based on the following priority
  # * The first privileged user (or non-prived RT user that is mapped to a Jira user)
  # * The first non-privileged user
  my $firstreqname = $anonuser;
  my $firstexternalemail;
  while ( my $requestor = $requestors->Next ) {
    # loop through to see if any of the requestors is a Jira user
    if (isAnon($requestor)){
      $firstexternalemail=$requestor->EmailAddress unless $firstexternalemail; # preserve the firstexternalmail
      $firstreqname=$anonuser;
    } else {
      $firstreqname=mapUser($requestor);
      $firstexternalemail="";
      last;
    }
  }

  # If we have a firstexternalmail, add a blurb to the description about it
  # Otherwise, we'd just have a bunch of tickets assigned to $anonuser with no way to track it
  if ($firstexternalemail) {
    $ticketdesc="Requested by Non-Jira User: $firstexternalemail\n".$ticketdesc;
  }

  $ticketdesc=JellyWriter::cleanXML($ticketdesc);
  $ticketdesc=JellyWriter::escapeJellyReservedChars($ticketdesc);

  # Create Issue
  $jellywriter->jellyStartCreateIssue(
    mapQueueToProject($ticket->QueueObj->Name),
    $ticket->Subject,
    mapPriority($ticket->Priority),
    $firstreqname,
    $jiraowner,
    $ticketdesc,
    fmtDateSQL2Jelly($ticket->Created),
    fmtDateSQL2Jelly($ticket->LastUpdated),
  );

  # Insert RT3 Ticket Number Custom Field
  $jellywriter->jellyAddCustomFieldValue($rttktidfn, $ticket->Id);

  #my $CustomFields = $ticket->CustomFields;
  #while ( my $CustomField = $CustomFields->Next ) {
  #  my $Values = $ticket->CustomFieldValues( $CustomField->Id );
  #  my $count = $Values->Count;
  #  my $fn=mapCFNames($CustomField->Name);
  #  #printf STDERR "Processing CustomField %s (%d values)\n", $CustomField->Name, $count;
  #  while ( my $Value = $Values->Next ) {
  #    jellyAddCustomFieldValue($fn, $Value->Content);
  #  }
  #}
  processTicketCustomFields($ticket);

  # End Issue
  $jellywriter->jellyFinishCreateTicket();
}

# foreach comment: generate jelly script to add a comment to existing ticket
sub processTicketTransactions($) {
  my $Ticket=shift;     # input RT::Ticket object
  my $Transactions = $Ticket->Transactions; # Transactions from the current ticket
  my $type;             # transaction type
  my %transtypectr;     # Keep count of each transaction type we encounter per ticket

  # RT tickets can be in any state, open or closed. Jira jelly creates tickets in the "Open" state which is equivalent to the "new" state in RT.
  # The transaction record may or may not record the creation of the ticket, but we need to make sure that we don't try to do a re-open on a Jira "open" or "In Progress" ticket.
  # Additionally, the create transaction record doesn't track the initial state of the ticket, making it tough to get a full history
  # Jira Jelly won't let us set the creation date of a workflow transition either, so all that matters is to record the final state of the RT ticket.

  my $finalstatus=$Ticket->Status;
  my $reopenctr=0;      # track if the ticket has been reopened
  my $laststatususer;   # track who the last user to do a status change on a ticket is
  my $lastcloseduser;   # track who last closed the ticket
  while (my $Transaction = $Transactions->Next) {

    $type=$Transaction->Type;
    $transtypectr{$type}++;
    #printf STDERR "Transaction %d has type \"%s\"\n", $Transaction->Id, $type;

    if ( $type =~ /^(Comment|Correspond)$/i ) {
      # Process transaction as a comment
      Transaction2Comment($Transaction);
    }
    elsif ( ($type =~ /Status/) && ($Transaction->Field eq 'Status') ) {
      $laststatususer=mapUser($Transaction->CreatorObj);

      my $oldstatus=$Transaction->OldValue;
      my $newstatus=$Transaction->NewValue;

      # track the last user to close a ticket is
      if ($newstatus =~ /^(rejected|resolved|deleted)$/) {
        $lastcloseduser=mapUser($Transaction->CreatorObj);
      }

      # Track re-opens
      if ( ( $oldstatus =~ /^(rejected|resolved|deleted)$/) &&
        ($newstatus =~ /^(new|open|stalled)$/ ) 
      ) {
        $reopenctr++;
      }

      # Process transaction as a workflow transition
      # Transaction2WorkflowTransition($Transaction, $transtypectr{$type});
    }
    elsif ($type =~ /^(Create|CommentEmailRecord|EmailRecord|AddWatcher|DelWatcher|Give|Take|Steal|Set|AddLink|DeleteLink|CustomField|Told|AddReminder|ResolveReminder|Told)$/i ) {
      # transactions we know about that we can skip
      # we skip Create transactions since the comment associated with Create is the Jira Issue description
    }
    else {
      # Skip unknown transaction types
      printf STDERR "Skipping unknown RT transaction type %s in transaction %d\n", $type, $Transaction->Id;
    }
  }

  # Finally, set the status of the Jira issue based on it's current state and whether it's been reopened or not
  # if we're in an open state and reopenctr > 0
  #   generate a close and then a reopen
  # else just generate a transaction based on the final state
  # Since we don't know who to blame for each commit, we're not going to track whether or not the ticket is in proress or not, just open or closed.

  if ( $finalstatus =~ /^(new|stalled|open)$/ ){
    if ($reopenctr) {
      # TODO: We don't track whether previous close was a fixed or won't fix situation
      $jellywriter->jellyWkFlowCloseIssue("Fixed",$lastcloseduser);
      $jellywriter->jellyWkFlowReopenIssue($laststatususer);
    }
    # else - since jira issues created in jelly are already in an open state, we'll do nothing
  } elsif ( $finalstatus =~ /^(rejected|resolved|deleted)$/ ) {
    $jellywriter->jellyWkFlowCloseIssue(mapResolution($finalstatus),$laststatususer);
  }
  else {
    die(sprintf("Unknown final status %s encountered on Ticket %d",$finalstatus,$Ticket->Id));
  }
}

# RT states to Jira resolutions
my %resolutionmap = (
  rejected => "Won't Fix",
  deleted => "Won't Fix",
  resolved => "Fixed",
);

sub mapResolution($){
  my $rtstatus=shift;
  my $res="Fixed";

  $res = $resolutionmap{$rtstatus} if exists $resolutionmap{$rtstatus};
  return $res;
}

# process a transaction that results in a Jira comment
sub Transaction2Comment($) {
  my $Transaction=shift;

  return 1 unless $Transaction->ContentObj; # Bail out if this has no content

  my $creatorobj = $Transaction->CreatorObj;
  my $transuser = mapUser($creatorobj);
  my $transcontent = $Transaction->Content;
  my $transdate = fmtDateSQL2Jelly($Transaction->Created);

  # for some reason there are some Comments in our queue that have no actual 
  # text content, but there is a ContentObj associated with them.
  # Skip those transactions with the null string as content
  return 1 unless $transcontent;

  if (isAnon($creatorobj)){
    # extract original user info
    my $origuser=$creatorobj->Name;
    my $origemail=$creatorobj->EmailAddress;
    # pre-pend blurb to comment
    $transcontent="Comment from Non-Jira User: $origuser <$origemail>\n".$transcontent;
  }
  $jellywriter->jellyAddComment($transuser,$transdate,$transcontent); # Add the Jelly Command
  return 0;
}

#process a transaction that results in a Jira Workflow transition
sub Transaction2WorkflowTransition($) {
  my $Transaction = shift;
  my $oldstatus = $Transaction->OldValue;
  my $newstatus = $Transaction->NewValue;
  my $user = mapUser($Transaction->CreatorObj);

  if ( $oldstatus =~ /^(new|stalled)$/ ) {
    # Jira Issue should be in an "Open" state
    if ( $newstatus =~ /^(new|stalled)$/ ) {
      return 1;# do nothing
    }
    elsif ($newstatus eq 'open') {
      $jellywriter->jellyWkFlowStartProgress($user);
      return 1;
    }
    elsif ( $newstatus =~ /^(rejected|deleted|resolved)$/ ) {
      $jellywriter->jellyWkFlowCloseIssue(&mapResolution($newstatus), $user);
      return 1;
    }
  } 
  elsif ($oldstatus eq 'open') {
    # Jira Issue should be in an "In Progress" state
    if ( $newstatus =~ /^(new|stalled)$/ ){
      $jellywriter->jellyWkFlowStopProgress($user);
      return 1;
    }
    elsif ( $newstatus =~ /^(rejected|deleted|resolved)$/ ) {
      $jellywriter->jellyWkFlowCloseIssue(mapResolution($newstatus), $user);
      return 1;
    }
  }
  elsif ($oldstatus =~ /^(rejected|resolved|deleted)$/) {
    # Jira Issue should be in a closed state
    if ( $newstatus eq "new" ) {
      $jellywriter->jellyWkFlowReopenIssue($user);
      return 1;
    }
    elsif ( $newstatus eq "open" ) {
      $jellywriter->jellyWkFlowReopenIssue($user);
      $jellywriter->jellyWkFlowStartProgress($user);
      return 1;
    }
    elsif ( $oldstatus eq "rejected" && $newstatus eq "resolved" ){
      # do nothing - handle ticket #369 which should have stayed in "rejected" state
      return 1;
    }
  }


  # Unknown RT status
  printf STDERR "ERROR: Transaction %d -- Unhandled RT Status Transition %s -> %s", $Transaction->Id, $oldstatus, $newstatus;
  return 1;
}

# Format a Date in SQL format in a Jira Jelly-ready format
sub fmtDateSQL2Jelly ($) {
  my $sqldate=shift;    # input date in SQL date format
  my $date_obj;         # RT::Date parser
  my $result;           # output in Jelly format

  $date_obj = RT::Date->new( RT->SystemUser ); 
  $date_obj->Set(
    Format => 'sql',
    Value  => $sqldate,
  );
  $result = strftime("%Y-%m-%d %H:%M:%S.0", 
    @{ [ localtime( $date_obj->Unix ) ] } );

  return $result;
}

sub processTicket($) {
  my $ticket = shift;
  print STDERR "Processing RT Ticket #" . $ticket->Id . "\n";
  $jellywriter->setIssueKey("rt".$ticket->Id);

  &processTicketObj($ticket);

  &rt3jiramigrate::processTicketTransactions($ticket);
}

######### MAIN #########

# Initilize our connection to RT
initRT();

# print banner
# print STDERR loc('Hello!') . "\n";

# Get a list of all tickets in RT
# Since RT::Tickets inherits from DBIx::SearchBuilder, no results show up
# unless search conditions are specified.
my $tickets= new RT::Tickets($RT::SystemUser);
$tickets->LimitId( OPERATOR => '>', VALUE => '0');
# Comment previous line and uncomment the following two lines for test tix
#$tickets->LimitId(OPERATOR => '>', VALUE => '1300');
#$tickets->LimitId(OPERATOR => '<', VALUE => '1350');

my $numtix = $tickets->Count; #total number of tickets
my $numfiles = &POSIX::ceil($numtix/$numtixperfile);
my $curfileidx=1; # current file index

# Print how many tickets we have
print STDERR "\$tickets->Count is ".$numtix."\n";
my $padlen = length($numtix);

# Issues
while (my $ticket = $tickets->Next) {
  if (($tickets->_ItemsCounter-1)%$numtixperfile == 0){
    # close the existing file if any
    if ($jellywriter) {
      $jellywriter->finishJellyOutput();
    }

    # Start a new file
    # get ready to write Jelly
    my $filename = sprintf("%s/%s%0".$padlen."d_of_%d%s",
      $outdir,
      $outfnprefix,
      $curfileidx,
      $numfiles,
      $outfnsuffix
    );
    printf STDERR "Starting new file \"%s\"\n", $filename;
    $jellywriter=new JellyWriter( Filename=>$filename );
    $jellywriter->startJellyOutput($filename);
    $curfileidx++; #increment the current file counter
  }
  processTicket($ticket);
}

# finish up our XML document
$jellywriter->finishJellyOutput() if $jellywriter;

print STDERR "The following users should be created:\n\t";
print STDERR join "\n\t", keys %JellyWriter::users;
print STDERR "\n";

print STDERR "The following users are treated as Anonymous\n\t";
print STDERR join "\n\t", keys %anonusers;
print STDERR "\n";

print STDERR "The following Custom Fields should be created:\n\t";
print STDERR join "\n\t", keys %JellyWriter::customfields;
print STDERR "\n";

print STDERR "\n------------\n";
print STDERR "Unique values in the custom fields (for use with Multi Select Jira fields):";
foreach my $fn (keys %JellyWriter::customfields){
  next if ($fn =~ /^RT3/);

  print STDERR "Field $fn:";
  print STDERR Dumper( $JellyWriter::customfields{$fn} );

  print "\n";
}
