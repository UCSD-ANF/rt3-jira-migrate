#!/opt/csw/bin/perl
#
use warnings;
use strict;

package rt3jiramigrate;

# Modify this to point to the Request Tracker installation location
use lib "/opt/rt3/lib";

# Need this to make sure we're writing clean XML
use XML::Writer;
use IO::File;

# Import RT's API
use RT::Interface::CLI qw(CleanEnv loc);
use RT::Tickets;
use Data::Dumper;

use POSIX;

#
# Configuration
#

my $outfilename="rt3-jira-migrate.out.jelly"; # Output file location for JIRA Jelly

#
# Instance variables
#

my @components; # List of components to create
my @milestones; # List of milestones to create
my @users; # List of users to create

my $writer; # XML-Writer instance for Jelly file
my $output; # Output IO handle for XML-Writer

# Map of RT users to Jira users
my %usermap = (
  'rob'           => 'rnewman',
  'rmellors@geology.sdsu.edu' => 'rmellors',
  'lastiz@ucsd.edu' => 'lastiz',
  'RT_System' => 'davis',
  'Nobody' => 'davis',
  'eakins@epicenter.ucsd.edu' => 'eakins',
  'davis@epicenter.ucsd.edu' => 'davis',
  'jeakins@unavco.org' => 'eakins',
  'danny@brtt.com' => 'danny',
  'leyer@ucsd.edu' => 'leyer',
  'pavlis@indiana.edu' => 'pavlis',
  'allan.sauter@gmail.com' => 'sauter',
  'geoff@geoffdavis.com' => 'davis',
  'busby@iris.edu' => 'busby',
  'rnitz@comm-systems.com' => 'rnitz',
  'jkim@sciences.sdsu.edu' => 'jkim',
  'vernon@brtt.com' => 'vernon',
  'davidechavez@gmail.com' => 'chavez',
  'jbytof@ucsd.edu' => 'bytof',
  'thim22@gmail.com' => 'thim',
  'dcconstant@ucsd.edu' => 'delia',
  'root' => 'davis',
  'reyes@ucsd.edu' => 'reyes',
  'hafner@iris.edu' => 'hafner',
  'k9pv@sdc.org' => 'k9pv',
  'eakins.jennifer@gmail.com' => 'eakins',
  'judy@ucsd.edu' => 'judy',
  'jdigjudy@gmail.com' => 'judy',
  'tshansen@nlanr.net' => 'tshansen',
  'tshansen@ucsd.edu' => 'tshansen',
);

# Function to map RT users to Jira users
sub mapUser($){
  my $user=shift;
  my $default = shift;

  die if ref ($user);

  return $default if ($user eq "");

  $user = $usermap{$user} if exists $usermap{$user};

  push (@users,$user) unless grep (/^$user$/,@users);
  return $user;
}

# Remove invalid XML unicode characters
# This function ensures that the output string has only valid XML Unicode 
# characters as specified by the XML 1.0 standard. For reference, please 
# see the standard: 
#   http://www.w3.org/TR/REC-xml/#charsets
#
# This function will return an empty string if the input is null or empty.
#
# Solution cobbled together based on this post:
# http://cse-mjmcl.cse.bris.ac.uk/blog/2007/02/14/1171465494443.html
sub cleanXML($) {
  my $input=shift;
  my $output=$input; # string to hold the output
  unless ($input) {
    print STDERR "cleanXML: no input\n";
    return '';
  }

  $output =~ s/[^\x{0009}\x{000A}\x{000D}\x{0020}-\x{D7FF}\x{E000}-\x{FFFD}\x{10000}-\x{10FFFF}]//g;
  #printf STDERR "cleanXML: removed %d chars from input\n", length($input)-length($output);
  return $output;
}

# Map of RT priority numbers to Jira priorities
my %prioritymap = (
  3     =>      "Major",
  2     =>      "Critical",
  4     =>      "Minor",
  1     =>      "Blocker",
  5     =>      "Trivial",
  99    =>      "Blocker",
  0     =>      "Trivial",
  15    =>      "Major",
  10    =>      "Major",
);

# Function to map RT priorities to Jira Priorities
sub mapPriority($){
  my $priority=shift;
  my $default = "Minor";
  return $default if ($priority eq "");

  if ( exists($prioritymap{$priority}) ){
    $priority = $prioritymap{$priority};
  } else {
    print STDERR "Fallback to Jira priority $default for RT priority $priority\n";
    $priority = $default;
  }
  return $priority;
}

my %queuemap = (
  General       => "SYS",
  LACOFD        => "LACOFD",
  ROADNet       => "ROADNET",
  ANZA          => "ANZA",
  SysAdmin      => "SYS",
  webapps       => "WWW",
  Backups       => "BACKUP",
  WebDev        => "WWW",
  USArray       => "TA",
  HiSeasNet     => "HSN",
  PBO           => "PBO",
);

# Map RT Quenename to Jira project Key
sub mapQueueToProject($){
  my $queue=shift;
  my $default="SYS";

  return $default if ($queue eq "");

  if (exists $queuemap{$queue}) {
    $queue=$queuemap{$queue};
  } else {
    print STDERR "Fallback to $default project for RT queue $queue\n";
    $queue=$default;
  }
  return $queue;
}

# Initilize RT
sub initRT {
  CleanEnv(); # Clean out all the nasties from the environment
  RT::LoadConfig(); # Load RT's config file
  RT::Init(); # Connect to the database. Set up logging

  return
}

sub startJellyOutput () {
# Start outputting XML
  $output = new IO::File(">$outfilename");
  $writer = new XML::Writer(OUTPUT => $output, 
    ENCODING => 'utf-8',
    #   NEWLINES => 'true',
    DATA_MODE => 'true',
    DATA_INDENT => '2'
  );

  $writer->xmlDecl();

# Start Writing Jelly
  $writer->startTag('JiraJelly', 'xmlns:jira' => 'jelly:com.atlassian.jira.jelly.enterprise.JiraTagLib');

  return;
}

sub finishJellyOutput () {
  # Done with Jelly
  $writer->endTag('JiraJelly');

# Finish outputting XML
  $writer->end();
  $output->close();
}

sub getRTTicketDescription($){
  my $Ticket = shift;

  my $Transactions = $Ticket->Transactions;

  return unless $Transactions->Count > 0;

  my $Transaction = $Transactions->First;

  return $Transaction->Content;
}

sub jellyCreateTicket($) {
  my $ticket = shift;
  my $ownerUser = new RT::User($RT::SystemUser);
  $ownerUser->Load($ticket->Owner);

  my $requestors = $ticket->Requestors->UserMembersObj;
  my $firstrequestor = "";
  $firstrequestor = $requestors->Next->Name unless ($requestors->Count < 1);

  # Create Issue
  $writer->startTag('jira:CreateIssue', 
    'project-key' => mapQueueToProject($ticket->QueueObj->Name),
    issueKeyVar => 'key',
    summary => $ticket->Subject,
    priority => mapPriority($ticket->Priority),
    reporter => mapUser($firstrequestor),
    assignee => mapUser($ownerUser->Name),
    description => cleanXML(getRTTicketDescription($ticket)),
  );

  # Insert RT3 Ticket Number Custom Field
  $writer->emptyTag('jira:AddCustomFieldValue',
    id=>'RT3 Ticket Number', value=>$ticket->Id);

  my $CustomFields = $ticket->CustomFields;
  while ( my $CustomField = $CustomFields->Next ) {
    my $Values = $ticket->CustomFieldValues( $CustomField->Id );
    my $count = $Values->Count;
    #printf STDERR "Processing CustomField %s (%d values)\n", $CustomField->Name, $count;
    while ( my $Value = $Values->Next ) {
      $writer->emptyTag('jira:AddCustomFieldValue',
        id=>$CustomField->Name, value=> $Value->Content);
    }
  }

  # End Issue
  $writer->endTag('jira:CreateIssue');
}

# foreach comment: generate jelly script to add a comment to existing ticket
sub processTicketTransactions($) {
  my $Ticket=shift;     # input RT::Ticket object
  my $Transactions = $Ticket->Transactions; # Transactions from the current ticket
  my $type;             # transaction type

  while (my $Transaction = $Transactions->Next) {

    $type=$Transaction->Type;
    #printf STDERR "Transaction %d has type \"%s\"\n", $Transaction->Id, $type;

    if ( $type =~ /^(Create|Comment|Correspond)$/i ) {
      # Process transaction as a comment
      Transaction2Comment($Transaction);
    }
    elsif ( ($type =~ /Status/) && ($Transaction->Field eq 'Status') ) {
      # Process transaction as a workflow transition
      Transaction2WorkflowTransition($Transaction);
    }
    elsif ($type =~ /^(CommentEmailRecord|EmailRecord|AddWatcher|DelWatcher|Give|Take|Steal|Set|AddLink|DeleteLink|CustomField|Told|AddReminder|ResolveReminder|Told)$/i ) {
      # transactions we know about that we can skip
    }
    else {
      # Skip unknown transaction types
      printf STDERR "Skipping unknown RT transaction type %s in transaction %d\n", $type, $Transaction->Id;
    }
  }
}

sub jellyWkFlowStartProgress($){
  my $user=shift;
  $writer->emptyTag('jira:TransitionWorkflow',
    key => '${key}',
    user => $user,
    workflowAction => 'Start Progress',
  );
}

sub jellyWkFlowStopProgress($){
  my $user=shift;
  $writer->emptyTag('jira:TransitionWorkflow',
    key => '${key}',
    user => $user,
    workflowAction => 'Stop Progress',
  );
}

sub jellyWkFlowCloseIssue($$){
  my $user=shift;
  my $resolution=shift;

  $writer->emptyTag('jira:TransitionWorkflow',
    key => '${key}',
    user => $user,
    workflowAction => 'Close Issue',
    resolution => $resolution,
  );
}

sub jellyWkFlowReopenIssue($){
  my $user=shift;
  $writer->emptyTag('jira:TransitionWorkflow',
    key => '${key}',
    user => $user,
    workflowAction => 'Reopen Issue',
  );
}

# RT states to Jira resolutions
my %resolutionmap = (
  rejected => "Won't Fix",
  deleted => "Won't Fix",
  resolved => "Fixed",
);

sub mapResolution($){
  my $rtstatus=shift;
  my $res="Fixed";

  $res = $resolutionmap{$rtstatus} if exists $resolutionmap{$rtstatus};
  return $res;
}

# process a transaction that results in a Jira comment
sub Transaction2Comment($) {
  my $Transaction=shift;

  return 1 unless $Transaction->ContentObj; # Bail out if this has no content

  my $transuser = &rt3jiramigrate::mapUser($Transaction->CreatorObj->Name);
  my $transcontent = $Transaction->Content;
  my $transdate = fmtDateSQL2Jelly($Transaction->Created);

  # for some reason there are some Comments in our queue that have no actual 
  # text content, but there is a ContentObj associated with them.
  # Skip those transactions with the null string as content
  return 1 unless $transcontent;
  &jellyAddComment($transuser,$transdate,$transcontent); # Add the Jelly Command
  return 0;
}

#process a transaction that results in a Jira Workflow transition
sub Transaction2WorkflowTransition($) {
  my $Transaction = shift;
  my $oldstatus = $Transaction->OldValue;
  my $newstatus = $Transaction->NewValue;
  my $user = mapUser($Transaction->CreatorObj->Name);

  if ( $oldstatus =~ /^(new|stalled)$/ ) {
    # Jira Issue should be in an "Open" state
    if ( $newstatus =~ /^(new|stalled)$/ ) {
      return 1;# do nothing
    }
    elsif ($newstatus eq 'open') {
      jellyWkFlowStartProgress($user);
      return 1;
    }
    elsif ( $newstatus =~ /^(rejected|deleted|resolved)$/ ) {
      jellyWkFlowCloseIssue($user,&mapResolution($newstatus));
      return 1;
    }
  } 
  elsif ($oldstatus eq 'open') {
    # Jira Issue should be in an "In Progress" state
    if ( $newstatus =~ /^(new|stalled)$/ ){
      jellyWkFlowStopProgress($user);
      return 1;
    }
    elsif ( $newstatus =~ /^(rejected|deleted|resolved)$/ ) {
      jellyWkFlowCloseIssue($user,mapResolution($newstatus));
      return 1;
    }
  }
  elsif ($oldstatus =~ /^(rejected|resolved|deleted)$/) {
    # Jira Issue should be in a closed state
    if ( $newstatus eq "new" ) {
      jellyWkFlowReopenIssue($user);
      return 1;
    }
    elsif ( $newstatus eq "open" ) {
      jellyWkFlowReopenIssue($user);
      jellyWkFlowStartProgress($user);
      return 1;
    }
    elsif ( $oldstatus eq "rejected" && $newstatus eq "resolved" ){
      # do nothing - handle ticket #369 which should have stayed in "rejected" state
      return 1;
    }
  }


  # Unknown RT status
  printf STDERR "ERROR: Transaction %d -- Unhandled RT Status Transition %s -> %s", $Transaction->Id, $oldstatus, $newstatus;
  return 1;
}

# Format a Date in SQL format in a Jira Jelly-ready format
sub fmtDateSQL2Jelly ($) {
  my $sqldate=shift;    # input date in SQL date format
  my $date_obj;         # RT::Date parser
  my $result;           # output in Jelly format

  $date_obj = RT::Date->new( RT->SystemUser ); 
  $date_obj->Set(
    Format => 'sql',
    Value  => $sqldate,
  );
  $result = strftime("%Y-%m-%d %H:%M:%S.0", 
    @{ [ localtime( $date_obj->Unix ) ] } );

  return $result;
}

# Output Jira Jelly to add a comment. Assumes that the issueKeyVar of the previous ticket was set to "key"
sub jellyAddComment($$$){
  my $commenter = shift;
  my $date = shift;
  my $comment = shift;

  $writer->emptyTag('jira:AddComment',
    'issue-key'=>'${key}',
    commenter=>$commenter,
    date=>$date,
    comment=>&rt3jiramigrate::cleanXML($comment));
}

sub processTicket($) {
  my $ticket = shift;
  print STDERR "Processing RT Ticket #" . $ticket->Id . "\n";

  &jellyCreateTicket($ticket);

  &rt3jiramigrate::processTicketTransactions($ticket);
}

######### MAIN #########

# Initilize our connection to RT
initRT();

# print banner
# print STDERR loc('Hello!') . "\n";

# Get a list of all tickets in RT
# Since RT::Tickets inherits from DBIx::SearchBuilder, no results show up
# unless search conditions are specified.
my $tickets= new RT::Tickets($RT::SystemUser);
$tickets->LimitId( OPERATOR => '>', VALUE => '0');
# Comment previous line and uncomment the following two lines for test tix
#$tickets->LimitId(OPERATOR => '>', VALUE => '1300');
#$tickets->LimitId(OPERATOR => '<', VALUE => '1350');

# Print how many tickets we have
my $count = $tickets->Count;
print STDERR "\$tickets->Count is ".$tickets->Count."\n";

# get ready to write Jelly
startJellyOutput();

# Issues
$writer->comment('ISSUES');
while (my $ticket = $tickets->Next) {
  processTicket($ticket);
}

# finish up our XML document
finishJellyOutput();

print STDERR "The following users should be created:\n\t";
print STDERR join "\n\t", @users;
print STDERR "\n";
